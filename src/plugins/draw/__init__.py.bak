import difflib
import json
import asyncio
import random
from nonebot import logger, on_message, on_regex
from nonebot.rule import fullmatch
from nonebot import on_message
from nonebot.adapters.onebot.v11 import GroupMessageEvent, Bot, MessageSegment
from httpx import AsyncClient
from nonebot import on_startswith
from nonebot import on_command
from nonebot.adapters import Message
from nonebot.params import CommandArg
from nonebot.plugin import PluginMetadata
from nonebot.typing import T_State

# 指令前缀
command_arg = "牛牛画图"
# 最大图片检查次数
max_check_image_number = 1000
# Lora 的总权重
total_weight = 100
# Lora 关键词的匹配值
lora_matcher_ratio = 0.8
# 模型关键词的匹配值
model_matcher_ratio = 0.15
# Kamiya API Key
kamiya_api_key = "sk-4QM9VWd1ACatZiaeuGxGJgpfHkzwnZceJ9FlZcNZrwyoPPMY"



# 以下变量非必要不更改！！！影响执行逻辑！！！
# Kamiya 绘图服务的网址
kamiya_api_draw_url = "https://p0.kamiya.dev/api/image/generate/"
# Kamiya 绘图服务获取配置的网址
kamiya_api_getconfig_url = "https://p0.kamiya.dev/api/image/config"
# 向 Kamiya API 提交的验证Header
kamiya_api_header = {
    "Content-Type": "application/json",
    "Authorization": "Bearer {}".format(kamiya_api_key)
}
# 向 Kamiya 绘图服务发送的 Payload 数据
kamiya_api_payload = {
    "type": "text2image",
    "prompts": "None",
    "negativePrompts": "lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry",
    "step": 28,
    "cfg": 12,
    "seed": 218506577,
    "sampling": "DPM++ 2M Karras",
    "width": 768,
    "height": 512,
    "model": "original",
    "LoRAs": [{}]
}

matcher = on_startswith(command_arg, ignorecase=True)
lora_matcher = difflib.SequenceMatcher()
model_matcher = difflib.SequenceMatcher()

@matcher.handle()
async def _(bot: Bot, event: GroupMessageEvent):
    
    split_message = str(event.message).split(" ")

    # 将所有中文逗号全部替换为英文，并分割提示词。
    # 该过程出现 IndexError 错误则代表未输入提示词。
    try:
        prompts = split_message[1].replace("，",",")
    except IndexError:
        await matcher.finish("您的输入有误!\n指令用法: 牛牛画图 [提示词]")

    await matcher.send("命令解析成功!\n开始获取Kamiya端侧数据...")

    try:
        async with AsyncClient() as client:
            response = await client.get(kamiya_api_getconfig_url, headers=kamiya_api_header, timeout=10)
    except httpcore.ReadTimeout:
        await matcher.finish("获取数据失败，因为Kamiya端响应超时。")

    if response.status_code != 200:
        await matcher.finish("获取Kamiya端侧数据失败...\n状态码: {}".format(get_response.status_code))

    # 读取data数据
    raw_data = response.json()["data"]
    
    # 读取服务状态
    busy_status = raw_data["busyStatus"]    

    # 开始匹配Lora模型
    await matcher.send("获取Kamiya端侧数据成功，开始解析数据...\n{}。".format(busy_status))

    # 匹配 Model
    await matcher.send("开始匹配Model...")
    for data_item in prompts.split(","):
        model_found_match = False
    
        for item in raw_data["availableModels"]:
            description = item.get("description", "")
            model_matcher.set_seqs(data_item, description)  # 设置序列
            ratio = model_matcher.ratio() # 计算相似度
        
            if ratio > model_matcher_ratio:  # 设置一个阈值，当相似度大于model_matcher_ratio时认为是匹配项
                id_value = item.get("id", "ID not found")
                await matcher.send("已匹配到Kamiya端侧Model数据!\nlora:{},id:{},raw_prompts{},ratio:{}".format(data_item, id_value, prompts, ratio))
                model_found_match = True
                # 优先拼接Model
                kamiya_api_payload["model"] = id_value
                break  # 找到匹配项后跳出循环
            break

        if not model_found_match:
            await matcher.send("未匹配到Kamiya端侧Model数据，使用默认模型...\nlora:{},ratio:{}".format(data_item,ratio))

    # 定义匹配的Lora字典
    lora_dict = {}

    # 匹配LoRAs
    await matcher.send("开始匹配LoRAs...")
    for data_item in prompts.split(","):
        lora_found_match = False
    
        for item in raw_data["availableLoRAs"]:
            name = item.get("name", "")
            lora_matcher.set_seqs(data_item, name)  # 设置序列
            ratio = lora_matcher.ratio() # 计算相似度
        
            if ratio > lora_matcher_ratio:  # 设置一个阈值，当相似度大于lora_matcher_ratio时认为是匹配项
                id_value = item.get("id", "ID not found")
                await matcher.send("已匹配到Kamiya端侧Lora数据!\nlora:{},id:{},raw_prompts{},ratio:{}".format(data_item, id_value, prompts, ratio))
                lora_found_match = True
                lora_dict[data_item] = id_value # 将匹配成功的lora放入字典
                break  # 找到匹配项后跳出循环

        if not lora_found_match:
            await matcher.send("未匹配到Kamiya端侧Lora数据!\nlora:{},ratio:{}".format(data_item,ratio))

    lora_dict_length = len(lora_dict)

    if lora_dict_length > 0:
        await matcher.send("总计匹配{}个了Lora，开始计算权重...\nraw_lora:{}".format(lora_dict_length, lora_dict))
        
        weights = {}
        lora_dict_final = {}

        # 计算lora
        weights_sum = sum(range(1, lora_dict_length + 1))
        for idx, key in enumerate(lora_dict.keys()):
            weight = total_weight * (lora_dict_length - idx) / weights_sum
            weights[key] = int(weight)

        # 为lora字典添加权重
        for key, weight in weights.items():
            lora_dict_final[key] = {"id": lora_dict[key], "weight": weight}
    
        lora_dict_values_only = list(lora_dict_final.values())
        await matcher.send("权重计算完毕！\n{}".format(lora_dict_values_only))
    else:
        lora_dict_values_only = {}
        await matcher.send("未匹配到Lora，不计算权重...")

    await matcher.send("开始拼接Payload...")

    # 开始拼接Payload
    kamiya_api_payload["prompts"] = prompts
    kamiya_api_payload["LoRAs"] = lora_dict_values_only
    kamiya_api_payload["seed"] = random.randint(1,100000000)

    await matcher.send("Payload拼接结果:\n{}\n预提交数据...".format(json.dumps(kamiya_api_payload)))

    # 提交绘图请求
    await matcher.send("提交中...")
    try:
        async with AsyncClient() as client:
            response = await client.post(kamiya_api_draw_url, headers=kamiya_api_header, data=json.dumps(kamiya_api_payload), timeout=10)
    except httpcore.ReadTimeout:
        await matcher.finish("提交数据失败，因为Kamiya端侧响应超时。")

    if response.status_code != 200:
        await matcher.finish("提交Payload数据失败...\n状态码: {}\n返回数据:{}".format(response.status_code,response.json()))

    try:
        returned_json = response.json()["data"]
        hash_id = returned_json["hashid"]
    except KeyError:
        await matcher.send(response)
        await matcher.finish("解析返回数据失败，因为Kamiya端侧返回了错误的数据。")

    await matcher.send("提交Payload数据成功!\n等待Kamiya端侧返回数据...")
    
    # 开始异步检测图片绘制状态
    task = asyncio.create_task(check_image(hash_id))

    try:
        success, url = await asyncio.wait_for(task, timeout=180)  # 设置超时时间为60秒
        if success:
            await matcher.finish("图片生成成功!\n{}".format(url))
        else:
            await matcher.finish("图片生成失败。因为已超过{}次最大尝试检测次数，或检测时出现了错误。".format(max_check_image_number))
    except asyncio.TimeoutError:
        await matcher.finish("图片生成失败。因为Kamiya端侧未返回图片数据。")



async def check_image(hash_id: str) -> (bool, str):

    check_number = 0

    while True:
        try:
            logger.info("检查中...")

            # 检查是否超过最大次数
            if check_number >= max_check_image_number:
                logger.info("生成失败，超过最大次数")
                return False, "None"

            async with AsyncClient() as client:
                check_number += 1
                response = await client.get("{}{}".format(kamiya_api_draw_url, hash_id), headers=kamiya_api_header, timeout=5)
        
            raw_data = response.json()["data"]

            # 状态为生成成功
            if raw_data["status"] == "generated":
                logger.info("生成成功")
                meta_data = raw_data["metadata"]

                url = meta_data["jpg"]

                return True, url

            await asyncio.sleep(5)
        except Exception:
            logger.info("生成失败，出现错误")
            return False, "None"

    logger.info("生成失败，不应出现的错误")
    return False, "None"

